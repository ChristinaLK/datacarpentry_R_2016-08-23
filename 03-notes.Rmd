---
layout: topic
title: Data frames (notes)
author: Data Carpentry contributors
minutes: 30
---

```{r, echo=FALSE, purl=FALSE}
knitr::opts_chunk$set(results='hide', fig.path='img/r-lesson-')
surveys <- read.csv("data/portal_data_joined.csv")
```

## stringsAsFactors

Avoid factors with `stringsAsFactors=FALSE`.

```{r}
surveys_chr <- read.csv("data/portal_data_joined.csv", stringsAsFactors=FALSE)
```

```{r}
str(surveys_chr)
```


## Constructing data frames "by hand"

```{r, results='show'}
df1 <- data.frame(animal=c("dog", "cat", "sea cucumber", "sea urchin"),
                  feel=c("furry", "furry", "squishy", "spiny"),
                  weight=c(45, 8, 1.1, 0.8))
str(df1)

df2 <- data.frame(animal=c("dog", "cat", "sea cucumber", "sea urchin"),
                  feel=c("furry", "furry", "squishy", "spiny"),
                  weight=c(45, 8, 1.1, 0.8), stringsAsFactors=FALSE)
str(df2)
```


### Challenge

There are a few mistakes in this hand crafted `data.frame`, can you spot and
fix them? Don't hesitate to experiment!

```{r, eval=FALSE}
author_book <- data.frame(author_first=c("Charles", "Ernst", "Theodosius"),
                          author_last=c(Darwin, Mayr, Dobzhansky),
                          year=c(1942, 1970))
```

<!-- end challenge -->


## Inspecting data frames

```{r}
dim(surveys)
nrow(surveys)
ncol(surveys)

names(surveys)
rownames(surveys)

summary(surveys)
```

## Indexing, sequences, subsetting

```{r}
surveys[1,1]

surveys[2,7]

surveys[2,]

sex <- surveys[,7]
```

Referring to columns.

```{r, eval = FALSE}
species_id <- surveys[, "sex"]
species_id <- surveys[["sex"]]
species_id <- surveys$sex
```


### Treating blanks as missing

```{r}
surveys_noblanks <- read.csv("data/portal_data_joined.csv", na.strings=c("", "NA"))
```

### Slices

As with vectors, you can also use logical vectors when indexing.

```{r}
weights_males <- surveys[surveys$sex == 'M', "weight"]
mean(weights_males, na.rm=TRUE)

mean(surveys[surveys$sex == 'F', "weight"], na.rm=TRUE)
```

Or you can use numeric vectors. To pull out larger slices, it's
helpful to have ways of creating sequences of numbers.

First, `:`


```{r}
1:10
10:1
5:8
```

`seq` is more flexible.

```{r}
seq(1, 10, by=2)
seq(5, 10, length.out=3)
seq(50, by=5, length.out=10)
seq(1, 8, by=3) # sequence stops to stay below upper limit
seq(10, 2, by=-2)  # can also go backwards
```

Use these to take slices of the data.

```{r}
surveys[1:3, 7]   # first three elements in the 7th column
surveys[1, 1:3]   # first three columns in the first row
surveys[2:4, 6:7] # rows 2-4, columns 6-7
```

### Challenge

1. The function `nrow()` on a `data.frame` returns the number of rows. Use it,
   in conjuction with `seq()` to create a new `data.frame` called
   `surveys_by_10` that includes every 10th row of the survey data frame
   starting at row 10 (10, 20, 30, ...)

2. Create a `data.frame` containing only the observations from 1999 of the
   `surveys` dataset.



<br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/> <br/>
