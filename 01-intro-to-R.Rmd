---
layout: topic
title: Introduction to R
author: Data Carpentry contributors
minutes: 45
---


```{r, echo=FALSE, purl=FALSE, message = FALSE}
source("setup.R")
```

------------

> ## Learning Objectives
>
> * Familiarize participants with R syntax
> * Understand the concepts of objects and assignment
> * Understand the concepts of vector and data types
> * Get exposed to a few functions

------------

## Assignment operator

We can assign names to numbers and other objects with the assignment
operator, `<-`. For example:

```{r assign}
age <- 2016-1969
```

Type that into your script, and use <kbd>`Ctrl`</kbd> +
<kbd>`Enter`</kbd> to paste it to the console.

You can also use `=` as assignment, but that symbol can have other
meanings, and so I recommend sticking with the `<-` combination.

In RStudio, typing <kbd>Alt</kbd> + <kbd>-</kbd> will write ` <- ` in
a single keystroke.

If you've assigned a number to an object, you can then use it in
further calculations:

```{r sqrt, results="markup"}
sqrt(age)
```

You can assigned _that_ to something, and then use it.

```{r round_sqrt_age}
sqrt_age <- sqrt(age)
round(sqrt_age)
round(sqrt_age, 2)
```

## Object names

Objects can be given any name such as `x`, `current_temperature`, or
`subject_id`. You want your object names to be explicit and not too
long.

They cannot start with a number (`2x` is not valid, but `x2` is).

R is case sensitive
(e.g., `weight_kg` is different from `Weight_kg`). There are some names that
cannot be used because they are the names of fundamental functions in R (e.g.,
`if`, `else`, `for`, see
[here](https://stat.ethz.ch/R-manual/R-devel/library/base/html/Reserved.html)
for a complete list).

In general, even if it's allowed, it's best to not use
other function names (e.g., `c`, `T`, `mean`, `data`, `df`, `weights`). In doubt
check the help to see if the name is already in use.

It's also best to avoid
dots (`.`) within a variable name as in `my.dataset`. There are many functions
in R with dots in their names for historical reasons, but because dots have a
special meaning in R (for methods) and other programming languages, it's best to
avoid them. It is also recommended to use nouns for variable names, and verbs
for function names. It's important to be consistent in the styling of your code
(where you put spaces, how you name variable, etc.). In R, two popular style
guides are [Hadley Wickham's](http://adv-r.had.co.nz/Style.html) and
[Google's](https://google-styleguide.googlecode.com/svn/trunk/Rguide.xml).


### Challenge

What is the value of `y` after doing the following?

```{r, eval=FALSE}
x <- 55
y <- x * 2.2
x <- 100
```

<!-- end challenge -->

Objects don't get linked to each other, so if you change one, it won't
affect the values of any others.

## Objects in your workspace

The objects you create get added to your "workspace". You can list the
current objects with `ls()`.

```{r ls}
ls()
```

RStudio also shows thee objects in the Environment panel.


## Vectors and data types

```{r, echo=FALSE, purl=TRUE}
### Vectors and data types
```

A vector is a group of values, mainly either numbers or characters. You can
assign this set of values to a variable, just like you would for one item. For
example we can create a vector of animal weights:

```{r, purl=FALSE}
weights <- c(30, 100, 4000, 8000)
```

A vector can also contain text (character strings):

```{r, purl=FALSE}
animals <- c("rat", "cat")
```

There are many functions that allow you to inspect the content of a
vector. `length()` tells you how many elements are in a particular vector:

```{r, purl=FALSE}
length(weights)
length(animals)
```

An important feature of a vector, is that all of the elements are the same type of data.
The function `class()` indicates the class (the type of element) of an object:

```{r, purl=FALSE}
class(weights)
class(animals)
```

The function `str()` provides an overview of the object and the elements it
contains. It is a really useful function when working with large and complex
objects:

```{r, purl=FALSE}
str(weights)
str(animals)
```

You can add elements to your vector by using the `c()` function:

```{r, purl=FALSE}
animals <- c(animals, "dog") # adding at the end of the vector
animals <- c("mouse", animals) # adding at the beginning of the vector
```

What happens here is that we take the original vector `animals`, and we are
adding another item first to the end of the other ones, and then another item at
the beginning. We can do this over and over again to grow a vector, or assemble
a dataset. As we program, this may be useful to add results that we are
collecting or calculating.

We just saw 2 of the 6 **atomic vector** types that R uses: `"character"` and
`"numeric"`. These are the basic building blocks that all R objects are built
from. The other 4 are:

* `"logical"` for `TRUE` and `FALSE` (the boolean data type)
* `"integer"` for integer numbers (e.g., `2L`, the `L` indicates to R that it's an integer)
* `"complex"` to represent complex numbers (e.g. `1+4i`)
* `"raw"` that we won't discuss further

Vectors are one of the many **data structures** that R uses. Other important
ones are lists (`list`), matrices (`matrix`), data frames (`data.frame`) and
factors (`factor`).


### Challenge

What happens to vectors with mixed types?

```{r, echo=TRUE, eval=FALSE}
x <- c(1, 2, 3, 'a')

y <- c(1, 2, 3, TRUE)

z <- c('a', TRUE, 'b', 'c')

tricky <- c(1, '2', 3, 4)
```

Hint: use `class()`

<!-- end challenge -->

Vectors must all be of one type, and so R converts them.

`logical` → `numeric` → `character`


## Subsetting vectors

If we want to extract one or several values from a vector, we must provide one
or several indices in square brackets. For instance:

```{r, results='show', purl=FALSE}
animals <- c("mouse", "rat", "dog", "cat")
animals[2]
animals[c(1, 4)]
```

We can also repeat the indices to create an object with more elements than the
original one:

```{r, results='show', purl=FALSE}
more_animals <- animals[c(1, 2, 3, 2, 1, 4)]
```

R indexes start at 1. Programming languages like Fortran, MATLAB, and R start
counting at 1, because that's what human beings typically do. Languages in the C
family (including C++, Java, Perl, and Python) count from 0 because that's
simpler for computers to do.

### Challenge

Consider the `animals` vector.

```{r eval=FALSE}
animals <- c("mouse", "rat", "dog", "cat")
```

Subset to get the 2nd and 3rd values.


### Conditional subsetting

Another common way of subsetting is by using a logical vector: `TRUE` will
select the element with the same index, while `FALSE` will not:

```{r, results='show', purl=FALSE}
weights <- c(21, 54, 39, 17, 55)
weights[c(FALSE, TRUE, FALSE, FALSE, TRUE)]
```

Typically, these logical vectors are not typed by hand, but are the output of
other functions or logical tests. For instance, if you wanted to select only the
values above 50:

```{r, results='show', purl=FALSE}
weights > 50    # will return logicals with TRUE for the indices that meet the condition
## so we can use this to select only the values above 50
weights[weights > 50]
```

You can combine multiple tests using `&` (both conditions are true, AND) or `|`
(at least one of the conditions is true, OR):

```{r, results='show', purl=FALSE}
weights[weights < 30 | weights > 50]
weights[weights > 30 & weights < 50]
```

When working with vectors of characters, if you are trying to combine many
conditions it can become tedious to type. The function `%in%` allows you to test
if a value if found in a vector:

```{r, results='show', purl=FALSE}
animals <- c("mouse", "rat", "dog", "cat")
animals[animals == "cat" | animals == "rat"] # returns both rat and cat
animals %in% c("rat", "cat", "dog", "duck")
animals[animals %in% c("rat", "cat", "dog", "duck")]
```

### Challenge

Consider the following two vectors.

```{r, eval=FALSE}
animals <- c("mouse", "rat", "cat", "dog")
weights <- c(30, 180, 4000, 8000)
```

Subset `animals` with `weights < 200`.

<!-- end challenge -->



## Missing data

As R was designed to analyze datasets, it includes the concept of missing data
(which is uncommon in other programming languages). Missing data are represented
in vectors as `NA`.

```{r, purl=FALSE}
heights <- c(2, 4, 4, NA, 6)
```

When doing operations on numbers, most functions will return `NA` if the data
you are working with include missing values. It is a safer behavior as otherwise
you may overlook that you are dealing with missing data. You can add the
argument `na.rm=TRUE` to calculate the result while ignoring the missing values.

```{r, purl=FALSE}
mean(heights)
max(heights)
mean(heights, na.rm = TRUE)
max(heights, na.rm = TRUE)
```

If your data include missing values, you may want to become familiar with the
functions `is.na()` and `na.omit()`.
examples.


```{r, purl=FALSE}
## Extract those elements which are not missing values.
heights[!is.na(heights)]
## shortcut to that
na.omit(heights)
```


### Challenge

Why does the following give an error?

```{r mean_na, eval=FALSE}
v <- c(2, 4, 4, "NA", 6)
mean(v, na.rm=TRUE)
```

Why does the error message say the data are not numeric?

<!-- end challenge -->
